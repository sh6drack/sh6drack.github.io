<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#030305">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>POLARITY</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;400;600;800&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      font-family: 'Inter', -apple-system, sans-serif;
      background: #030305;
      color: #fff;
      -webkit-font-smoothing: antialiased;
      touch-action: none;
    }

    canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }

    /* Minimal UI */
    .ui {
      position: fixed;
      z-index: 100;
      pointer-events: none;
    }

    .logo {
      top: clamp(20px, 4vw, 40px);
      left: clamp(20px, 4vw, 40px);
      font-weight: 800;
      font-size: clamp(11px, 1.5vw, 14px);
      letter-spacing: 0.25em;
      opacity: 0.4;
    }

    .hint {
      bottom: clamp(20px, 4vw, 40px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      letter-spacing: 0.15em;
      opacity: 0.2;
      text-transform: uppercase;
      transition: opacity 0.5s;
    }

    .hint.hidden { opacity: 0; }

    /* Detail panel */
    .panel {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      background: linear-gradient(to top, rgba(3,3,5,0.98) 0%, rgba(3,3,5,0.9) 70%, transparent 100%);
      padding: clamp(30px, 6vw, 60px);
      padding-top: clamp(60px, 10vw, 100px);
      transform: translateY(100%);
      transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      pointer-events: none;
      z-index: 200;
    }

    .panel.active {
      transform: translateY(0);
      pointer-events: auto;
    }

    .panel-inner {
      max-width: 600px;
      margin: 0 auto;
    }

    .panel-category {
      font-size: 10px;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      opacity: 0.3;
      margin-bottom: 8px;
    }

    .panel-title {
      font-size: clamp(28px, 6vw, 42px);
      font-weight: 800;
      letter-spacing: -0.03em;
      margin-bottom: 16px;
      line-height: 1.1;
    }

    .panel-desc {
      font-size: clamp(14px, 2vw, 16px);
      font-weight: 200;
      line-height: 1.7;
      opacity: 0.6;
      max-width: 500px;
    }

    .panel-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 20px;
    }

    .panel-tag {
      font-size: 10px;
      letter-spacing: 0.1em;
      padding: 6px 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
    }

    .panel-close {
      position: absolute;
      top: clamp(20px, 4vw, 30px);
      right: clamp(20px, 4vw, 30px);
      width: 40px; height: 40px;
      background: rgba(255,255,255,0.05);
      border: none;
      border-radius: 50%;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.3s, transform 0.3s;
      pointer-events: auto;
    }

    .panel-close:hover {
      opacity: 1;
      transform: scale(1.1);
    }

    /* CTA */
    .cta {
      position: fixed;
      bottom: clamp(20px, 4vw, 40px);
      right: clamp(20px, 4vw, 40px);
      z-index: 300;
    }

    .cta-btn {
      background: rgba(78, 205, 196, 0.9);
      border: none;
      border-radius: 30px;
      padding: 14px 28px;
      font-size: 11px;
      font-weight: 600;
      color: #000;
      font-family: inherit;
      letter-spacing: 0.12em;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      pointer-events: auto;
    }

    .cta-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 30px rgba(78, 205, 196, 0.4);
    }

    /* Modal */
    .modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(3,3,5,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.4s;
      z-index: 500;
      padding: 20px;
    }

    .modal.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background: rgba(10,10,15,0.95);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      padding: clamp(30px, 6vw, 48px);
      max-width: 400px;
      width: 100%;
      text-align: center;
      transform: scale(0.95);
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .modal.active .modal-content {
      transform: scale(1);
    }

    .modal h2 {
      font-size: 24px;
      font-weight: 800;
      margin-bottom: 8px;
    }

    .modal p {
      font-size: 13px;
      opacity: 0.4;
      margin-bottom: 24px;
    }

    .modal form {
      display: flex;
      gap: 10px;
    }

    .modal input {
      flex: 1;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 14px;
      color: #fff;
      font-family: inherit;
      outline: none;
      min-width: 0;
    }

    .modal input:focus {
      border-color: rgba(78, 205, 196, 0.5);
    }

    .modal input::placeholder {
      color: rgba(255,255,255,0.25);
    }

    .modal button[type="submit"] {
      background: #4ECDC4;
      border: none;
      border-radius: 10px;
      padding: 14px 20px;
      font-size: 11px;
      font-weight: 600;
      color: #000;
      font-family: inherit;
      letter-spacing: 0.1em;
      cursor: pointer;
      white-space: nowrap;
    }

    .modal .close {
      position: absolute;
      top: 15px; right: 15px;
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      opacity: 0.3;
    }

    .modal .close:hover { opacity: 0.7; }

    .form-msg {
      margin-top: 16px;
      font-size: 13px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .form-msg.show { opacity: 1; }

    @media (max-width: 500px) {
      .modal form { flex-direction: column; }
      .modal button[type="submit"] { padding: 14px; }
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<div class="ui logo">POLARITY</div>
<div class="ui hint" id="hint">Drag to explore</div>

<div class="panel" id="panel">
  <button class="panel-close" id="panelClose">×</button>
  <div class="panel-inner">
    <div class="panel-category" id="panelCat"></div>
    <h2 class="panel-title" id="panelTitle"></h2>
    <p class="panel-desc" id="panelDesc"></p>
    <div class="panel-tags" id="panelTags"></div>
  </div>
</div>

<div class="cta">
  <button class="cta-btn" id="ctaBtn">WAITLIST</button>
</div>

<div class="modal" id="modal">
  <div class="modal-content">
    <button class="close" id="modalClose">×</button>
    <h2>Join the Waitlist</h2>
    <p>Be the first to map your mind</p>
    <form id="form">
      <input type="email" name="email" placeholder="you@email.com" required>
      <button type="submit">JOIN</button>
    </form>
    <div class="form-msg" id="formMsg"></div>
  </div>
</div>

<script>
const nodes = [
  { id: 'core', label: 'POLARITY', cat: 'Core', title: 'Your AI Exocortex',
    desc: 'A 3D neural knowledge graph mapping your mind to anatomically accurate brain regions. Talk naturally—Polarity extracts what you know.',
    tags: ['3D Brain', 'Knowledge Graph', 'Claude AI'], color: [78, 205, 196], size: 1.8, z: 0 },
  { id: 'brain', label: 'BRAINID', cat: 'Identity', title: 'Cognitive Identity',
    desc: '20 nodes unlock your unique identifier. Your knowledge graph becomes your credential—a fingerprint that evolves with you.',
    tags: ['Threshold', 'Portable', 'Evolving'], color: [78, 205, 196], size: 0.9, z: -2 },
  { id: 'auth', label: 'AUTH', cat: 'Security', title: 'Brain as Password',
    desc: 'Challenge-response from graph pathways. NBKDF key derivation. AES-256-GCM encrypted .polarity files.',
    tags: ['NBKDF', 'Challenges', 'Encrypted'], color: [187, 143, 206], size: 0.85, z: -1.5 },
  { id: 'time', label: 'TIME', cat: 'Temporal', title: 'Git for Your Mind',
    desc: 'Snapshots at midnight. Travel to any date. See exactly what changed in your knowledge.',
    tags: ['Snapshots', 'History', 'Diff'], color: [255, 160, 122], size: 0.8, z: 1.5 },
  { id: 'future', label: 'FUTURE', cat: 'Projection', title: 'Chat with Tomorrow',
    desc: 'Set a target date. AI generates projected knowledge. Chat with who you\'ll become.',
    tags: ['Timelines', 'Goals', 'Learning'], color: [78, 205, 196], size: 0.85, z: 2 },
  { id: 'traits', label: 'TRAITS', cat: 'Psychology', title: 'Pattern Detection',
    desc: 'Personality patterns from conversation. What you emphasize, avoid, how you think.',
    tags: ['Personality', 'Values', 'Style'], color: [187, 143, 206], size: 0.75, z: -1 },
  { id: 'agent', label: 'AGENTS', cat: 'Execution', title: 'AI Agent Modes',
    desc: 'Auto, Ask, or Plan mode. Full IDE integration—code view, file explorer, terminal.',
    tags: ['Auto', 'Ask', 'Plan', 'IDE'], color: [255, 160, 122], size: 0.8, z: 1 },
  { id: 'cloud', label: 'CLOUD', cat: 'Sync', title: 'Zero-Config Sync',
    desc: 'Device-based auth. BrainID verification. Free tier, $15 basic, $50 pro.',
    tags: ['Sync', 'Tiers', 'API Proxy'], color: [78, 205, 196], size: 0.7, z: -0.5 },
  { id: 'dual', label: 'DUAL', cat: 'Meta', title: 'AI That Knows Itself',
    desc: 'Polarity maintains its own knowledge base. Self-goals for continuous improvement.',
    tags: ['Self-Aware', 'Patterns', 'Goals'], color: [255, 160, 122], size: 0.75, z: 0.5 }
];

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy;
let dpr = Math.min(window.devicePixelRatio || 1, 2);

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.scale(dpr, dpr);
  cx = W / 2;
  cy = H / 2;
}
resize();
window.addEventListener('resize', resize);

// Camera
let camX = 0, camY = 0, camZ = 5;
let rotX = 0.3, rotY = 0;
let targetRotX = 0.3, targetRotY = 0;
let isDragging = false;
let lastX, lastY;
let autoRotate = true;

// Touch/mouse handling
function onStart(x, y) {
  isDragging = true;
  lastX = x; lastY = y;
  autoRotate = false;
  document.getElementById('hint').classList.add('hidden');
}

function onMove(x, y) {
  if (!isDragging) return;
  const dx = x - lastX;
  const dy = y - lastY;
  targetRotY += dx * 0.005;
  targetRotX += dy * 0.005;
  targetRotX = Math.max(-1, Math.min(1, targetRotX));
  lastX = x; lastY = y;
}

function onEnd() {
  isDragging = false;
}

canvas.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
canvas.addEventListener('mouseup', onEnd);
canvas.addEventListener('mouseleave', onEnd);

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  onStart(t.clientX, t.clientY);
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  onMove(t.clientX, t.clientY);
}, { passive: false });

canvas.addEventListener('touchend', onEnd);

// Project 3D to 2D
function project(x, y, z) {
  const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
  const cosY = Math.cos(rotY), sinY = Math.sin(rotY);

  let x1 = x * cosY - z * sinY;
  let z1 = x * sinY + z * cosY;
  let y1 = y * cosX - z1 * sinX;
  let z2 = y * sinX + z1 * cosX;

  z2 += camZ;
  const scale = 300 / z2;

  return {
    x: cx + x1 * scale,
    y: cy + y1 * scale,
    scale: scale,
    z: z2
  };
}

// Stars
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({
    x: (Math.random() - 0.5) * 20,
    y: (Math.random() - 0.5) * 20,
    z: (Math.random() - 0.5) * 20,
    size: Math.random() * 1.5
  });
}

// Node positions (orbital)
const nodePositions = [];
const coreIdx = 0;
nodePositions[0] = { x: 0, y: 0, z: 0 };

const orbitRadius = 2.5;
for (let i = 1; i < nodes.length; i++) {
  const angle = ((i - 1) / (nodes.length - 1)) * Math.PI * 2;
  const zOffset = nodes[i].z || 0;
  nodePositions[i] = {
    x: Math.cos(angle) * orbitRadius,
    y: Math.sin(angle) * orbitRadius * 0.6,
    z: zOffset
  };
}

// Detect node click
let selectedNode = null;

canvas.addEventListener('click', e => {
  if (isDragging) return;

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Check nodes (sorted by z for correct picking)
  const projected = nodes.map((n, i) => {
    const p = nodePositions[i];
    const proj = project(p.x, p.y, p.z);
    return { ...proj, idx: i, node: n };
  }).sort((a, b) => b.z - a.z);

  for (const p of projected) {
    const r = p.node.size * p.scale * 15;
    const dx = mx - p.x;
    const dy = my - p.y;
    if (dx * dx + dy * dy < r * r) {
      showPanel(p.node);
      return;
    }
  }
});

// Panel
const panel = document.getElementById('panel');
const panelCat = document.getElementById('panelCat');
const panelTitle = document.getElementById('panelTitle');
const panelDesc = document.getElementById('panelDesc');
const panelTags = document.getElementById('panelTags');

function showPanel(node) {
  panelCat.textContent = node.cat;
  panelTitle.textContent = node.title;
  panelTitle.style.color = `rgb(${node.color.join(',')})`;
  panelDesc.textContent = node.desc;
  panelTags.innerHTML = node.tags.map(t => `<span class="panel-tag">${t}</span>`).join('');
  panel.classList.add('active');
  selectedNode = node;
}

document.getElementById('panelClose').addEventListener('click', () => {
  panel.classList.remove('active');
  selectedNode = null;
});

// Modal
const modal = document.getElementById('modal');
document.getElementById('ctaBtn').addEventListener('click', () => modal.classList.add('active'));
document.getElementById('modalClose').addEventListener('click', () => modal.classList.remove('active'));
modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('active'); });

// Form
document.getElementById('form').addEventListener('submit', async e => {
  e.preventDefault();
  const email = e.target.email.value;
  const msg = document.getElementById('formMsg');

  try {
    const res = await fetch('https://formspree.io/f/xblvelep', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });

    if (res.ok) {
      msg.textContent = "You're on the list.";
      msg.style.color = '#4ECDC4';
      e.target.email.value = '';
    } else throw new Error();
  } catch {
    msg.textContent = 'Try again.';
    msg.style.color = '#FFA07A';
  }

  msg.classList.add('show');
  setTimeout(() => msg.classList.remove('show'), 4000);
});

// Animation
let time = 0;

function draw() {
  time += 0.016;

  // Smooth rotation
  if (autoRotate) {
    targetRotY += 0.002;
  }
  rotX += (targetRotX - rotX) * 0.08;
  rotY += (targetRotY - rotY) * 0.08;

  ctx.fillStyle = '#030305';
  ctx.fillRect(0, 0, W, H);

  // Stars
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  for (const s of stars) {
    const p = project(s.x, s.y, s.z);
    if (p.z > 0.5) {
      const alpha = Math.min(1, p.scale / 80) * 0.5;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s.size * p.scale * 0.02, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;

  // Connections
  const projectedNodes = nodes.map((n, i) => {
    const pos = nodePositions[i];
    // Subtle float
    const floatY = i === 0 ? 0 : Math.sin(time + i) * 0.05;
    return { ...project(pos.x, pos.y + floatY, pos.z), node: n, idx: i };
  });

  // Draw connections to core
  const core = projectedNodes[0];
  for (let i = 1; i < projectedNodes.length; i++) {
    const p = projectedNodes[i];
    const gradient = ctx.createLinearGradient(core.x, core.y, p.x, p.y);
    gradient.addColorStop(0, 'rgba(78, 205, 196, 0.15)');
    gradient.addColorStop(1, 'rgba(78, 205, 196, 0.02)');
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(core.x, core.y);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
  }

  // Sort by z for drawing
  projectedNodes.sort((a, b) => a.z - b.z);

  // Draw nodes
  for (const p of projectedNodes) {
    const n = p.node;
    const r = n.size * p.scale * 12;
    const isCore = n.id === 'core';

    // Glow
    const glowSize = isCore ? r * 3 : r * 2;
    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize);
    glow.addColorStop(0, `rgba(${n.color.join(',')}, ${isCore ? 0.3 : 0.15})`);
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Node
    const grad = ctx.createRadialGradient(p.x - r * 0.3, p.y - r * 0.3, 0, p.x, p.y, r);
    grad.addColorStop(0, `rgba(${n.color.map(c => Math.min(255, c + 60)).join(',')}, 1)`);
    grad.addColorStop(1, `rgb(${n.color.join(',')})`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fill();

    // Label
    const labelAlpha = Math.min(1, (p.scale - 30) / 50);
    if (labelAlpha > 0) {
      ctx.fillStyle = `rgba(255,255,255,${labelAlpha * 0.5})`;
      ctx.font = `500 ${Math.max(9, r * 0.4)}px Inter`;
      ctx.textAlign = 'center';
      ctx.fillText(n.label, p.x, p.y + r + 16);
    }
  }

  requestAnimationFrame(draw);
}

draw();

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    panel.classList.remove('active');
    modal.classList.remove('active');
  }
});
</script>

</body>
</html>
